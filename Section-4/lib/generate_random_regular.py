from __future__ import division

from collections import Counter

import networkx as nx
from networkx.generators.classic import empty_graph
from networkx.utils import discrete_sequence
from networkx.utils import weighted_choice
from networkx.utils import py_random_state
@py_random_state(4)
def bipartite_random_uniform_k_out_graph(n,m, prob, with_replacement=False,
                               seed=None):
    """Returns a random `k`-out graph with uniform attachment.

    A random `k`-out graph with uniform attachment is a multidigraph
    generated by the following algorithm. For each node *u*, choose
    `k` nodes *v* uniformly at random (with replacement). Add a
    directed edge joining *u* to *v*.

    Parameters
    ----------
    n : int
        The number of nodes in the first bipartite set.
    m : int
        The number of nodes in the second bipartite set.

    k : int
        The out-degree of each node in the first set.

    self_loops : bool
        If True, self-loops are allowed when generating the graph.

    with_replacement : bool
        If True, neighbors are chosen with replacement and the
        returned graph will be a directed multigraph. Otherwise,
        neighbors are chosen without replacement and the returned graph
        will be a directed graph.

    seed : integer, random_state, or None (default)
        Indicator of random number generation state.
        See :ref:`Randomness<randomness>`.

    Returns
    -------
    NetworkX graph
        A `k`-out-regular directed graph generated according to the
        above algorithm. It will be a multigraph if and only if
        `with_replacement` is True.

    Raises
    ------
    ValueError
        If `with_replacement` is False and `k` is greater than
        `n`.

    See also
    --------
    random_k_out_graph

    Notes
    -----
    The return digraph or multidigraph may not be strongly connected, or
    even weakly connected.

    If `with_replacement` is True, this function is similar to
    :func:`random_k_out_graph`, if that function had parameter `alpha`
    set to positive infinity.

    """
    if (type(prob)==tuple):
        if len(prob)!=2:
             raise ValueError("parameter prob should be a 2-dim tuple, you insert a tuple of dimension: "+str(len(prob)))
    elif (type(prob)==float)or (type(prob)==int):
        prob=(prob,prob)
    else:
        raise ValueError("prob should be either float or a tuple, you insert"+str(type(prob)))
        
                
    if with_replacement:
        create_using = nx.MultiDiGraph()

        def sample(nodes,k):
            return (seed.choice(list(nodes)) for i in range(k))

    else:
        create_using = nx.DiGraph()

        def sample(nodes,k):
            return seed.sample(nodes, k)

    G = create_using
    G=_add_nodes_with_bipartite_label(G,n,m)
    top_nodes = set([n for n,d in G.nodes(data=True) if d['bipartite']==0])
    bottom_nodes = set([n for n,d in G.nodes(data=True) if d['bipartite']==1])
    nodes = set(G)
    for u in top_nodes:
        G.add_edges_from((u, v) for v in sample(bottom_nodes,prob[0]))
    for v in bottom_nodes:
        G.add_edges_from((v, u) for u in sample(top_nodes,prob[1]))

    return G
@py_random_state(4)
def bipartite_random_uniform_k_in_graph(n,m, prob, with_replacement=False,
                               seed=None):
    """Returns a random `k`-out graph with uniform attachment.

    A random `k`-out graph with uniform attachment is a multidigraph
    generated by the following algorithm. For each node *u*, choose
    `k` nodes *v* uniformly at random (with replacement). Add a
    directed edge joining *u* to *v*.

    Parameters
    ----------
    n : int
        The number of nodes in the first bipartite set.
    m : int
        The number of nodes in the second bipartite set.

    k : int
        The out-degree of each node in the first set.

    self_loops : bool
        If True, self-loops are allowed when generating the graph.

    with_replacement : bool
        If True, neighbors are chosen with replacement and the
        returned graph will be a directed multigraph. Otherwise,
        neighbors are chosen without replacement and the returned graph
        will be a directed graph.

    seed : integer, random_state, or None (default)
        Indicator of random number generation state.
        See :ref:`Randomness<randomness>`.

    Returns
    -------
    NetworkX graph
        A `k`-out-regular directed graph generated according to the
        above algorithm. It will be a multigraph if and only if
        `with_replacement` is True.

    Raises
    ------
    ValueError
        If `with_replacement` is False and `k` is greater than
        `n`.

    See also
    --------
    random_k_out_graph

    Notes
    -----
    The return digraph or multidigraph may not be strongly connected, or
    even weakly connected.

    If `with_replacement` is True, this function is similar to
    :func:`random_k_out_graph`, if that function had parameter `alpha`
    set to positive infinity.

    """
    if (type(prob)==tuple):
        if len(prob)!=2:
             raise ValueError("parameter prob should be a 2-dim tuple, you insert a tuple of dimension: "+str(len(prob)))
    elif (type(prob)==float)or (type(prob)==int):
        prob=(prob,prob)
    else:
        raise ValueError("prob should be either float or a tuple, you insert"+str(type(prob)))
        
                
    if with_replacement:
        create_using = nx.MultiDiGraph()

        def sample(nodes,k):
            return (seed.choice(list(nodes)) for i in range(k))

    else:
        create_using = nx.DiGraph()

        def sample(nodes,k):
            return seed.sample(nodes, k)

    G = create_using
    G=_add_nodes_with_bipartite_label(G,n,m)
    top_nodes = set([n for n,d in G.nodes(data=True) if d['bipartite']==0])
    bottom_nodes = set([n for n,d in G.nodes(data=True) if d['bipartite']==1])
    nodes = set(G)
    for u in top_nodes:
        G.add_edges_from((v, u) for v in sample(bottom_nodes,prob[0]))
    for v in bottom_nodes:
        G.add_edges_from((u, v) for u in sample(top_nodes,prob[1]))

    return G
def fast_coupling(N1,N2,cin,din,replace=False):
	''' This function generates the bi-adjacency matrix eta and xi  for random regular graph.
	Replace=False means that multiple links are allowed between the same pair of nodes, and they will  be accounted multiple times. 
	Replace=True forbids the generation of multiple links. But it is slower  '''
	if replace:#  it is very slow
		raise Warning("This is very slow implementation")
		row=array([numpy.random.choice(range(N1),cin,replace=False) for i in range(N2)]).ravel()
		col=array([cin*[i] for i in arange(N2)]).ravel()
		data=ones(cin*N2)
		eta=scipy.sparse.coo_matrix((data,(row,col)),shape=(N1,N2))
		row=array([numpy.random.choice(range(N2),din,replace=False) for i in range(N1)]).ravel()
		col=array([din*[i] for i in arange(N1)]).ravel()
		data=ones(din*N1)
		xi=scipy.sparse.coo_matrix((data,(row,col)),shape=(N2,N1))

	else:
		row=numpy.random.choice(range(N1),cin*N2)
		col=cin*list(arange(N2))
		data=ones(cin*N2)
		eta=scipy.sparse.coo_matrix((data,(row,col)),shape=(N1,N2))

		row=numpy.random.choice(range(N2),din*N1)
		col=din*list(range(N1))
		data=ones(din*N1)
		xi=scipy.sparse.coo_matrix((data,(row,col)),shape=(N2,N1))
	return eta,xi

def _add_nodes_with_bipartite_label(G, lena, lenb):
    G.add_nodes_from(range(0,lena+lenb))
    b=dict(zip(range(0,lena),[0]*lena))
    b.update(dict(zip(range(lena,lena+lenb),[1]*lenb)))
    if nx.__version__>'2':
         nx.set_node_attributes(G,b,'bipartite')
    else:
         nx.set_node_attributes(G,'bipartite',b)         
    return G

